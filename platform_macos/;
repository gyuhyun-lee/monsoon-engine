#include <Cocoa/Cocoa.h> 
#include <OpenGL/gl.h>

struct macos_opengl_info
{
    
};

static CVReturn 
DisplayLinkCallback(CVDisplayLinkRef displayLink, const CVTimeStamp* now, const CVTimeStamp* outputTime,
                CVOptionFlags flagsIn, CVOptionFlags* flagsOut, void* displayLinkContext)
{
    // CVReturn result = [(__bridge fox_openGL_view*)displayLinkContext getFrameForTime:outputTime];
    // return result;
    return kCVReturnSuccess;
}

int main(int argc, char **argv)
{
    NSApplication *App = [NSApplication sharedApplication]; // Your program should invoke this method as one of the first statements in main();
    [App setActivationPolicy :NSApplicationActivationPolicyRegular]; // The application is an ordinary app that appears in the Dock and may have a user interface.

    NSFileManager *FileManager = [NSFileManager defaultManager];
    NSString *BundlePath = [[NSBundle mainBundle] bundlePath];
	NSString *ResourcePath = [NSString stringWithFormat:@"%@/Contents/Resources", BundlePath];

    NSMenu *AppMainMenu = [NSMenu alloc];
    NSMenuItem *MenuItemWithAppName = [NSMenuItem new];
    [AppMainMenu addItem : MenuItemWithAppName];
	[NSApp setMainMenu:AppMainMenu];
    
    
	NSMenu *SubMenuOfMenuItemWithAppName = [NSMenu alloc];
	NSMenuItem *quitMenuItem = [[NSMenuItem alloc] initWithTitle:@"Quit" 
                    action:@selector(terminate:)  // Decides what will happen when the menu is clicked or selected
                    keyEquivalent:@"q"];
	[SubMenuOfMenuItemWithAppName addItem:quitMenuItem];
	[MenuItemWithAppName setSubmenu:SubMenuOfMenuItemWithAppName];


    //- (instancetype)initWithTitle:(NSString *)title;
    //- (void)addItem:(NSMenuItem *)newItem;

	int BufferWidth = 960;
	int BufferHeight = 540;
    int BytesPerPixel = 4;
    int BufferPitch = BufferWidth * BytesPerPixel;
    void *GameBufferMemory = malloc(BufferPitch * BufferHeight);

    uint8 *FirstPixelOfRow = (uint8 *)GameBufferMemory;
    for(int Row = 0;
        Row < BufferHeight;
        ++Row)
    {
        uint_32 *Pixel = (uint32 *)(FirstPixelOfRow);
        for(int Column = 0;
            Column < BufferWidth;
            ++Column)
        {
        }

        FirstPixelOfRow += BufferPitch;
    }

	NSRect windowFrameRect = NSMakeRect(100.0f, 100.0f, (float)BufferWidth, (float)BufferHeight);

	NSWindow *window = [[NSWindow alloc] initWithContentRect : windowFrameRect
											// Apple window styles : https://developer.apple.com/documentation/appkit/nswindow/stylemask
											styleMask : NSTitledWindowMask|NSWindowStyleMaskClosable|NSWindowStyleMaskResizable
											backing : NSBackingStoreBuffered 
											defer : NO];

	NSString *AppName = [[NSProcessInfo processInfo]processName];
	[window setTitle:AppName];
	[window makeKeyAndOrderFront:0];

    NSOpenGLPixelFormatAttribute OpenGLPixelFormatAttributes[] = 
        {NSOpenGLPFADoubleBuffer, 
        NSOpenGLPFAAccelerated,
        NSOpenGLPFAColorSize, 24,
        NSOpenGLPFAAlphaSize, 8,
        0};
    
    NSOpenGLPixelFormat *OpenGLPixelFormat = [[NSOpenGLPixelFormat alloc] initWithAttributes : OpenGLPixelFormatAttributes];
    NSOpenGLContext *OpenGLContext = [[NSOpenGLContext alloc] initWithFormat : OpenGLPixelFormat shareContext : 0];
    NSOpenGLView *OpenGLView = [[NSOpenGLView alloc] initWithFrame : windowFrameRect 
                                                    pixelFormat : OpenGLPixelFormat];

    CVDisplayLinkRef DisplayLink;
    // kCVReturnSuccess has constant value of 0..
    if(CVDisplayLinkCreateWithActiveCGDisplays(&DisplayLink)== kCVReturnSuccess)
    {
        // TODO : Double-check whether setting a output callback function even matters.
        CVDisplayLinkSetOutputCallback(DisplayLink, DisplayLinkCallback, 0); 
        CVDisplayLinkSetCurrentCGDisplayFromOpenGLContext(DisplayLink, [OpenGLContext CGLContextObj], [OpenGLPixelFormat CGLPixelFormatObj]);
        CVDisplayLinkStart(DisplayLink);
    }
    [OpenGLContext makeCurrentContext];

    
	GLuint TextureID;
    glEnable(GL_TEXTURE_2D);
    glDisable(GL_DEPTH_TEST);
    // GL_UNPACK_ALIGNMENT affects how to unpack the given texture(in out case, our output buffer)
    // TODO : why 1 byte alignment?
    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
    glActiveTexture(GL_TEXTURE0);
    glGenTextures(1, &TextureID);
    glBindTexture(GL_TEXTURE_2D, TextureID);

    glTexImage2D(GL_TEXTURE_2D, 0, 
                GL_RGBA8, // Format of our buffer?
                BufferWidth, BufferHeight,
                0, 
                GL_BGRA, 
                GL_UNSIGNED_INT_8_8_8_8_REV, 
                GameBufferMemory);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);


	[window setContentView:OpenGLView];
	[OpenGLView setOpenGLContext:OpenGLContext];
	//[OpenGLView setOpenGLPixelFormat:OpenGLPixelFormat];
	[OpenGLContext setView:OpenGLView];

	[NSApp activateIgnoringOtherApps:YES];
	[NSApp run];

    while(1)
    {
			// CGLLockContext(macosOpenGLInfo.cglContext);
		    glClear(GL_COLOR_BUFFER_BIT);
		    glBindTexture(GL_TEXTURE_2D, TextureID);
		    // Upload new video frame to the GPU.
			// glTexImage2D(GL_TEXTURE_2D, 0, GL_BGRA, gameBuffer.width, gameBuffer.height,
			// 			0, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, gameBuffer.memory);
			glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, BufferWidth, BufferHeight,
						0, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, GameBufferMemory);

		    // Draw textured full-viewport quad.
		    glBegin(GL_QUADS); 
		    {
		        glTexCoord2f(0.0f, 1.0f); glVertex2f(-1.0f, 1.0f);
		        glTexCoord2f(1.0f, 1.0f); glVertex2f( 1.0f, 1.0f);
		        glTexCoord2f(1.0f, 0.0f); glVertex2f( 1.0f,  -1.0f);
		        glTexCoord2f(0.0f, 0.0f); glVertex2f(-1.0f,  -1.0f);
		    } glEnd();

			[OpenGLContext flushBuffer];
		    // CGLUnlockContext(macosOpenGLInfo.cglContext);
    }

    return 0;
}
